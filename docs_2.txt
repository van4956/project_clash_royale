================================================================================
                    ДОКУМЕНТАЦИЯ ПРОЕКТА CLASH ROYALE BOT
================================================================================

ОГЛАВЛЕНИЕ:
-----------
1. ОБЗОР ПРОЕКТА
2. АРХИТЕКТУРА СИСТЕМЫ
3. ПОТОК ДАННЫХ (от запуска до завершения)
4. МОДУЛИ И КЛАССЫ
5. ОСНОВНЫЕ ФУНКЦИИ
6. ДЕТАЛИ РЕАЛИЗАЦИИ

================================================================================
1. ОБЗОР ПРОЕКТА
================================================================================

Clash Royale Bot - программа для анализа игрового процесса Clash Royale в
реальном времени. Отслеживает действия противника, вычисляет баланс эликсира
и предсказывает цикл карт в руке оппонента.

ОСНОВНЫЕ ФУНКЦИИ:
- Детекция игровых объектов с помощью YOLO11 (165 классов)
- Отслеживание цикла карт противника (8 карт: 4 в руке + 4 в ожидании)
- Расчет баланса эликсира противника (0-10)
- Визуализация данных через оверлей поверх игры
- Обработка красных таймеров, заклинаний, абилок чемпионов, эво-маркеров

ТЕХНОЛОГИИ:
- Python 3.10
- YOLO11 (Ultralytics) для детекции объектов
- MSS для быстрого захвата экрана
- Tkinter + PIL для отрисовки оверлея
- OpenCV для обработки изображений

РЕЖИМ РАБОТЫ:
- FPS: 4 кадра в секунду (настраиваемо)
- Детекция в выбранной области экрана (ROI)
- Работа в реальном времени без задержек

================================================================================
2. АРХИТЕКТУРА СИСТЕМЫ
================================================================================

2.1 СТРУКТУРА ПРОЕКТА
--------------------

project_13_ClashBot/
├── app.py                      # Главный файл, точка входа
├── config.py                   # Конфигурация (константы, пути, настройки)
├── modules/                    # Модули системы
│   ├── __init__.py
│   ├── screen_capture.py      # Захват экрана (ROI selection, MSS)
│   ├── yolo_detector.py       # YOLO детектор (инференс модели)
│   ├── overlay_static.py      # Статичные элементы (доска, капелька)
│   ├── overlay_dynamic.py     # Динамические элементы (шкала, карты)
│   ├── game_state.py          # Глобальное состояние игры
│   ├── card_manager.py        # Менеджер цикла карт
│   ├── detection_handler.py   # Координатор обработки детекций
│   ├── timer_processor.py     # Обработка красных таймеров
│   ├── spell_processor.py     # Обработка заклинаний
│   ├── ability_processor.py   # Обработка абилок чемпионов
│   ├── evolution_processor.py # Обработка эво-маркеров
│   ├── classes.py             # Классы данных (Card, TimerObject)
│   ├── functions.py           # Вспомогательные функции
│   └── all_card.py            # База данных всех карт (121 шт)
├── models/                    # Обученные YOLO модели
├── data/                      # Ресурсы (картинки карт, иконки)
├── detection/                 # Отладочные скриншоты с детекциями
└── roi_config.txt             # Сохраненные координаты ROI

2.2 АРХИТЕКТУРА (схема потоков данных)
--------------------------------------

                        ┌──────────────────┐
                        │   USER SCREEN    │
                        │   (игра Clash)   │
                        └─────────┬────────┘
                                  │
                        ┌─────────▼────────────┐
                        │  ScreenCapture (MSS) │ ← Выбор ROI пользователем
                        │   capture_frame()    │
                        └─────────┬────────────┘
                                  │ frame (BGR image)
                        ┌─────────▼────────────┐
                        │  YoloDetector (YOLO) │
                        │   model.predict()    │
                        └─────────┬────────────┘
                                  │ detections [{'class_name', 'box', 'conf'}]
                        ┌─────────▼─────────────────┐
                        │  detection_handler.py     │
                        │  process_detections()     │
                        └─────────┬─────────────────┘
                                  │
          ┌───────────────────────┼───────────────────────┐
          │                       │                       │
┌─────────▼─────────┐   ┌─────────▼─────────┐   ┌─────────▼────────┐
│ timer_processor   │   │ spell_processor   │   │ ability_processor│
│ evolution_proc... │   │                   │   │                  │
└─────────┬─────────┘   └────────┬──────────┘   └────────┬─────────┘
          │                      │                       │
          └──────────────────────┼───────────────────────┘
                                 │ elixir_spent
                        ┌────────▼──────────┐
                        │   GameState       │
                        │ - log_screen      │
                        │ - timer_list      │
                        │ - spell_dict_*    │
                        │ - card_manager    │
                        │ - elixir_balance  │
                        └────────┬──────────┘
                                 │
                    ┌────────────┼────────────┐
                    │                         │
          ┌─────────▼──────────┐    ┌─────────▼───────┐
          │  DynamicOverlay    │    │  StaticOverlay  │
          │ - шкала эликсира   │    │ - доска         │
          │ - цифра            │    │ - капелька      │
          │ - карты (8 шт)     │    │                 │
          └────────────────────┘    └─────────────────┘

2.3 КЛЮЧЕВЫЕ КОМПОНЕНТЫ
-----------------------

1. ScreenCapture (modules/screen_capture.py):
   - Интерактивный выбор области экрана (ROI)
   - Быстрый захват кадров через MSS (4 FPS)
   - Сохранение/загрузка координат в roi_config.txt

2. YoloDetector (modules/yolo_detector.py):
   - Загрузка модели YOLO11
   - Инференс на каждом кадре
   - Возврат детекций: class_name, box, confidence

3. GameState (modules/game_state.py):
   - Централизованное хранилище данных о бое
   - log_screen: последние 4 кадра с детекциями
   - timer_list: активные таймеры (для юнитов и зданий)
   - spell_dict_hand, spell_dict_our, spell_dict_enemy: словари для заклинаний
   - ability_dict_enemy: активные вражеские абилки
   - evolution_dict_timer: маркеры эволюций
   - card_manager: менеджер цикла карт противника
   - elixir_balance: баланс эликсира противника

4. CardManager (modules/card_manager.py):
   - deck_cards: список всех 121 карт (уменьшается по мере открытия)
   - await_cards: 4 карты в ожидании (слева на панели)
   - hand_cards: 4 карты в руке (справа на панели)
   - play_known_card(): обработка известной карты
   - play_new_card(): обработка новой (неизвестной ранее) карты из deck_cards

5. Detection Handler (modules/detection_handler.py):
   - Координирует обработку всех детекций
   - Вызывает процессоры: timer, spell, ability, evolution
   - Агрегирует elixir_spent
   - Обновляет elixir_balance в GameState

6. Процессоры (4 модуля):
   - timer_processor.py: красные таймеры (юниты/здания)
   - spell_processor.py: заклинания на поле
   - ability_processor.py: абилки чемпионов
   - evolution_processor.py: маркеры эволюций

7. Overlay (2 модуля):
   - overlay_static.py: статичная доска + капелька эликсира
   - overlay_dynamic.py: шкала, цифра, карты (обновляется каждый кадр)

================================================================================
3. ПОТОК ДАННЫХ (от запуска до завершения)
================================================================================

3.1 ИНИЦИАЛИЗАЦИЯ (app.py: main())
----------------------------------

1. Загрузка конфигурации (config.py)
2. Создание ScreenCapture()
3. Создание CardDetector()
4. Выбор ROI (load_roi() или select_roi())
5. Создание оверлеев (StaticOverlay, DynamicOverlay)
6. Загрузка модели YOLO (detector.load_model())
7. Инициализация GameState()

3.2 ОСНОВНОЙ ЦИКЛ (app.py: while True)
--------------------------------------

Шаг 1: Захват кадра
   screen_capture.capture_frame() → frame (BGR image)

Шаг 2: Детекция YOLO
   detector.detect(frame) → detections [{'class_name', 'box', 'conf'}]

Шаг 3: Проверка технических классов
   - Ищем "_ start": reset card_manager
   - Ищем "_ timer total": game_start_time = current_time
   - Ищем "_ finish": reset GameState, вывод метрик

Шаг 4: Обработка детекций (detection_handler)
   process_detections(detections, current_time, game_state, all_cards)
   │
   ├─> 1. game_state.add_frame(detections, timestamp)
   ├─> 2. _cleanup_all(game_state)
   │      ├─> timer_processor.cleanup_timers()
   │      └─> spell_processor.cleanup_spell_dict_hand()
   │
   ├─> 3. evolution_processor.process_evolution_detections()
   │      └─> Фиксация новых маркеров (_ evolution mark)
   │
   ├─> 4. timer_processor.process_timer_detections()
   │      ├─> Создание/обновление timer_obj
   │      ├─> Проверка условий (усл.1, усл.2, усл.3)
   │      ├─> Определение сыгранной карты
   │      └─> Запуск цикла карт + списание эликсира
   │
   ├─> 5. spell_processor.process_spell_detections()
   │      ├─> Обновление spell_dict_hand (НАША рука)
   │      ├─> Перенос в spell_dict_our при исчезновении
   │      ├─> Подсчет детекций заклинаний на поле
   │      ├─> Сравнение с known (our + enemy)
   │      └─> Обработка новых вражеских заклинаний
   │
   ├─> 6. ability_processor.process_ability_detections()
   │      ├─> Поиск абилок в детекциях
   │      ├─> Поиск _ lvl red cham в зоне
   │      └─> Списание эликсира (без запуска цикла)
   │
   ├─> 7. Агрегация elixir_spent
   │      total_elixir_spent = timer + spell + ability
   │
   └─> 8. game_state.update_elixir(current_time, total_elixir_spent)

Шаг 5: Обновление оверлеев
   overlay_dynamic.update_display(elixir_balance)
   overlay_dynamic.set_await_cards(await_cards)
   overlay_dynamic.set_hand_cards(hand_cards)

Шаг 6: Вывод в терминал
   - Количество детекций
   - Баланс эликсира
   - Цикл карт (await + hand)
   - Время обработки

Шаг 7: Сохранение кадра (если DETECTION_TEST=True)
   detector.draw_detections(frame) → detection/HH-MM-SS-ms.png

Шаг 8: Контроль FPS
   sleep_time = frame_interval - total_time

3.3 ЗАВЕРШЕНИЕ (finally:)
-------------------------

1. overlay_dynamic.close()
2. overlay_static.close()
3. screen_capture.cleanup()
4. Вывод статистики (обработано кадров)

================================================================================
4. МОДУЛИ И КЛАССЫ
================================================================================

4.1 CLASSES.PY - ОСНОВНЫЕ КЛАССЫ ДАННЫХ
---------------------------------------

@dataclass Card():
    Представляет карту Clash Royale.

    Атрибуты:
    - card_id: int                          # уникальный id
    - card_name: str                        # название на английском
    - image_path: str                       # путь к картинке
    - elixir: int                           # стоимость (1-10)
    - class_name: str | None                # class_name для детекций на поле
    - spell: bool                           # является заклинанием?
    - spell_life_time: int | None           # время действия заклинания (сек)
    - spell_my_hand_class_name: str | None  # "Z*" для детекций в НАШЕЙ руке
    - champion: bool                        # чемпион?
    - ability_class_name: str | None        # class_name абилки
    - ability_elixir: int                   # стоимость абилки
    - evolution: bool                       # есть эволюция?
    - evolution_image_path: str | None      # путь к картинке эво-версии
    - cnt_evo: int = 0                      # счетчик эво-маркеров
    - target_evo: int = 0                   # нужно маркеров для активации

    Примечание CV модели:
    - Префиксы class_name: W (Warrior), S (Spell), B (Building), A (Ability)
    - Вторая буква: C (Common), R (Rare), E (Epic), L (Legend), C (Champion)
    - Специальный префикс "Z" для заклинаний в НАШЕЙ руке (Zone icons)
    - Технические объекты: "_ timer red", "_ lvl red", "_ finish", и т.д.

@dataclass TimerObject(list):
    Представляет объект отслеживания красного таймера.
    Наследуется от list, содержит 6 timer_screen.

    Атрибуты:
    - first_screen: int | None        # время первой детекции
    - last_screen: int | None         # время последней детекции
    - list_ignore: list[str] | None   # class_name для игнорирования

    Структура timer_screen:
    [[box_timer], [box_zone], [[box_lvl], ...], [class_name, ...]]

    Методы:
    - del_last(): удаляет последний элемент (скользящее окно)
    - add_full(timer_screen): добавляет элемент спереди

4.2 GAME_STATE.PY - ГЛОБАЛЬНОЕ СОСТОЯНИЕ ИГРЫ
----------------------------------------------

class GameState:
    Централизованное хранилище данных о текущем бою.

    Атрибуты (хранение данных):
    - log_screen: deque(maxlen=4)              # последние 4 кадра
    - timer_list: List[TimerObject]            # активные таймеры
    - spell_dict_hand: Dict[str, List[int]]    # заклинания в НАШЕЙ руке
    - spell_dict_our: Dict[str, List[float]]   # НАШИ заклинания (таймауты)
    - spell_dict_enemy: Dict[str, List[float]] # ВРАЖЕСКИЕ заклинания (таймауты)
    - ability_dict_enemy: Dict[str, float]     # ВРАЖЕСКИЕ абилки
    - evolution_dict_timer: Dict[float, str]   # маркеры эво (таймауты)
    - card_manager: CardManager                # менеджер цикла карт

    Атрибуты (эликсир):
    - elixir_speed: float = 0.35               # скорость прироста
    - elixir_balance: float = 6.5              # баланс (0-10)
    - elixir_rate: float = 1.0                 # коэффициент (x2, x3)
    - elixir_spent: float = 0.0                # потрачено в итерации
    - elixir_negative: float = 0.0             # ушло в минус (метрика)
    - elixir_stagnation: float = 0.0           # простаивало >10

    Атрибуты (время):
    - game_start_time: float | None            # начало боя
    - time_screen: float | None                # последний кадр

    Методы:
    - reset(): сброс между боями
    - add_frame(detections, timestamp): добавить кадр в log
    - set_elixir_rate(class_name): установить множитель (x2/x3)
    - update_elixir(current_time, elixir_spent): обновить баланс
    - get_elixir_metrics(): получить метрики

4.3 CARD_MANAGER.PY - МЕНЕДЖЕР ЦИКЛА КАРТ
-----------------------------------------

class CardManager:
    Управляет циклом карт противника (deck → await → hand).

    Атрибуты:
    - deck_cards: List[Card]         # все 121 карты (уменьшается)
    - await_cards: List[Card]        # 4 карты в ожидании
    - hand_cards: List[Card]         # 4 карты в руке

    Методы (основные):
    - play_new_card(class_name, evolution_dict_timer):
        Обработка НОВОЙ карты (из deck_cards).
        Логика:
        1. Удаляем крайний левый card_random из hand
        2. Перемещаем await[3] → hand[index]
        3. Если в await[3] была не card_random -> проверяем активацию эволюции (cnt_evo >= target_evo)
        4. Обрабатываем эво-маркер (_process_evolution_marker)
        5. Вставляем новую карту в await[0] (сдвигает все элементы await вправо)
        6. Удаляем карту из deck_cards (которую установили в await[0])


    - play_known_card(class_name, evolution_dict_timer):
        Обработка ИЗВЕСТНОЙ карты (из hand_cards).
        Логика:
        1. Удаляем карту из hand, запоминаем index
        2. Перемещаем await[3] → hand[index] (проверяем cnt_evo >= target_evo)
        3. Сдвигаем сдвигаем await вправо
        4. Обрабатываем эво-маркер (_process_evolution_marker)
        5. Возвращаем карту в await[0]

    - _process_evolution_marker(card, evolution_dict_timer):
        Внутренний метод для обработки эво-маркеров.
        Условия:
        - У карты evolution=True
        - Есть маркер со статусом "detect"
        Действия:
        - Находим oldest маркер (find_oldest_detect_marker)
        - Меняем статус на "record" (mark_evolution_as_recorded)
        - Увеличиваем cnt_evo += 1

    Методы (вспомогательные):
    - card_random(): создать заглушку (Card_random)
    - get_hand_cards(): вернуть копию hand_cards
    - get_await_cards(): вернуть копию await_cards
    - is_card_in_hand(class_name): проверка наличия в руке
    - is_card_in_await(class_name): проверка наличия в ожидании
    - find_card_in_deck(class_name): поиск в deck_cards
    - count_card_random_in_hand(): подсчет заглушек
    - reset(): сброс состояния

4.4 DETECTION_HANDLER.PY - КООРДИНАТОР ОБРАБОТКИ
-----------------------------------------------

def process_detections(all_detections, current_time, game_state, all_cards):
    Главная функция координатор.

    Аргументы:
    - all_detections: список детекций [{class_name, box, conf}]
    - current_time: временная метка
    - game_state: объект GameState
    - all_cards: список всех карт (121 шт)

    Возвращает:
    {
        'elixir_spent_timer': float,
        'elixir_spent_spell': float,
        'elixir_spent_ability': float,
        'total_elixir_spent': float,
    }

    Последовательность:
    1. game_state.add_frame(detections, timestamp)
    2. _cleanup_all(game_state)
    3. evolution_processor.process_evolution_detections()
    4. timer_processor.process_timer_detections() (если есть _ timer red)
    5. spell_processor.process_spell_detections()
    6. ability_processor.process_ability_detections()
    7. Агрегация elixir_spent
    8. game_state.update_elixir(current_time, total_elixir_spent)
    9. Возврат results

def _cleanup_all(game_state):
    Очистка хвостов (скользящие окна).
    - timer_processor.cleanup_timers(timer_list)
    - spell_processor.cleanup_spell_dict_hand(spell_dict_hand)

def _has_red_timers(all_detections):
    Проверка наличия "_ timer red" в детекциях.

================================================================================
5. ОСНОВНЫЕ ФУНКЦИИ (ПРОЦЕССОРЫ)
================================================================================

5.1 TIMER_PROCESSOR.PY - ОБРАБОТКА КРАСНЫХ ТАЙМЕРОВ
---------------------------------------------------

Красные таймеры - основной сигнал размещения юнитов/зданий.
Самая сложная логика обработки (скользящее окно 6 кадров).

Главная функция:
def process_timer_detections(log_screen, timer_list, card_manager,
                              all_detections, timestamp, evolution_dict_timer):
    1. cleanup_timers(timer_list)
    2. Для каждого _ timer red:
       - create_timer_screen(box_timer, all_detections, log_screen)
       - find_matching_timer_obj(timer_list, timer_screen)
       - Если найден → update_timer_obj()
       - Если не найден → create_new_timer_obj()
    3. Для timer_obj с 5 элементами:
       - fill_missing_timer_screen()
    4. Для timer_obj с 6 элементами:
       - check_timer_conditions() → confirmed_card
       - Если карта определена → process_confirmed_timer()
    5. Удаление обработанных timer_obj
    6. Возврат elixir_spent

Вспомогательные функции:
- create_timer_screen(box_timer, all_detections, log_screen):
    Создает [[box_timer], [box_zone], [[box_lvl], ...], [class_name, ...]]
    + list_ignore из log_screen

- find_matching_timer_obj(timer_list, timer_screen, iou_threshold=0.8):
    Ищет существующий timer_obj по IoU сходству box_timer

- create_new_timer_obj(timer_screen, timestamp, list_ignore):
    Создает TimerObject с 6 timer_screen (1 + 5 пустых)

- update_timer_obj(timer_obj, timer_screen, timestamp):
    Добавляет timer_screen в начало, обновляет last_screen

- fill_missing_timer_screen(timer_obj, all_detections, timestamp):
    Заполняет пустой timer_screen (когда 5 элементов)

- check_timer_conditions(timer_obj, card_manager):
    Проверяет условия:
    Усл.1: cnt_box_timer() >= 3
    Усл.2: group_box_lvl() >= 1
    Усл.3: group_class_name() не пустой и не "_bomb"
    Определяет карту: hand → deck → await

- process_confirmed_timer(confirmed_card, card_manager, elixir_spent,
                          evolution_dict_timer):
    Запускает play_known_card() или play_new_card()
    Списывает эликсир

5.2 SPELL_PROCESSOR.PY - ОБРАБОТКА ЗАКЛИНАНИЙ
---------------------------------------------

Заклинания НЕ маркируются таймерами.
Определение по детекции эффекта на поле + сопоставление с НАШЕЙ рукой.

Три словаря заклинаний:
- spell_dict_hand: {"ZE_rage": [1,0,0,0], ...}  # НАША рука (окно)
- spell_dict_our: {"SE_rage": [timeout_1, ...]} # НАШИ активные (до 2)
- spell_dict_enemy: {"SE_rage": [timeout_1, ...]} # ВРАЖЕСКИЕ активные

Главная функция:
def process_spell_detections(all_detections, spell_dict_hand, spell_dict_our,
                              spell_dict_enemy, card_manager, current_time,
                              all_cards):
    1. cleanup_spell_dict_hand()
    2. update_spell_dict_hand() - обновление НАШЕЙ руки
    3. check_spell_dict_timeout(spell_dict_our, current_time)
    4. check_spell_dict_timeout(spell_dict_enemy, current_time)
    5. Подсчет детекций заклинаний на поле (класс начинается с "S")
    6. Для каждого заклинания:
       - Подсчет our_count + enemy_count = total_known
       - Если detected > known → новые вражеские заклинания
       - _process_new_enemy_spell() → найденная карта
       - Списание эликсира (ОДИН раз)
       - Добавление таймаутов (для всех new_enemy_count)
    7. Возврат elixir_spent

Вспомогательные функции:
- cleanup_spell_dict_hand(spell_dict_hand):
    Удаляет последний элемент из каждого списка (окно сдвигается)

- update_spell_dict_hand(all_detections, spell_dict_hand, spell_dict_our,
                         current_time, all_cards):
    1. Находим заклинания с префиксом "Z" (НАША рука)
    2. Обновляем spell_dict_hand: 1 или 0 в начало списка
    3. Проверяем [0,0,0,0] → переносим в spell_dict_our

- check_spell_dict_timeout(spell_dict_timeout, current_time):
    Фильтрация истекших таймаутов, удаление пустых ключей

- _process_new_enemy_spell(class_name, card_manager, all_cards):
    Поиск карты: hand → deck → await
    Запуск play_known_card() или play_new_card()

- _find_card_by_class_name(class_name, all_cards)
- _find_card_by_spell_my_hand_class_name(class_name, all_cards)

5.3 ABILITY_PROCESSOR.PY - ОБРАБОТКА АБИЛОК ЧЕМПИОНОВ
-----------------------------------------------------

Абилки НЕ влияют на цикл карт, только на баланс эликсира.
Определение владельца по наличию _ lvl red cham в зоне над абилкой.

Словарь абилок:
- ability_dict_enemy: {"AC_xxx": timeout_end, ...}

Главная функция:
def process_ability_detections(all_detections, ability_dict_enemy,
                                current_time, all_cards):
    1. check_ability_dict_timeout(ability_dict_enemy, current_time)
    2. Для каждой детекции с префиксом "A":
       - Проверка ability_dict_enemy (если есть → игнорим)
       - _find_red_level_in_zone(box_ability, all_detections)
       - Если найден красный уровень → ВРАЖЕСКАЯ абилка
         * Списание ability_elixir
         * Добавление в ability_dict_enemy
       - Если НЕ найден → НАША абилка (игнорим)
    3. Возврат elixir_spent

Вспомогательные функции:
- check_ability_dict_timeout(ability_dict_enemy, current_time):
    Удаление истекших таймаутов

- _find_red_level_in_zone(box_ability, all_detections):
    1. Расширяем box_ability ВВЕРХ на 0.5 высоты
    2. Ищем "_lvl_red_cham" в all_detections
    3. Проверяем пересечение через _is_box_in_zone()
    4. Возвращаем True если найден

- _is_box_in_zone(box, zone):
    Проверка пересечения (центр бокса в зоне)

- _find_card_by_ability_class_name(class_name, all_cards)

5.4 EVOLUTION_PROCESSOR.PY - ОБРАБОТКА ЭВО-МАРКЕРОВ
---------------------------------------------------

Маркеры сигнализируют об отыгрыше эво-версии карты.
Подсвечивают ТОЛЬКО вражеские эволюции.

Константа:
EVO_MARKER_DISPLAY_TIME = 3.0  # секунды

Словарь маркеров:
- evolution_dict_timer: {timestamp: status, ...}
  status: "detect" (обнаружен) или "record" (учтен в cnt_evo)

Главная функция:
def process_evolution_detections(all_detections, evolution_dict_timer,
                                  current_time):
    1. check_evolution_dict_timeout(evolution_dict_timer, current_time)
    2. Подсчет детектированных "_evolution_mark"
    3. Сравнение с len(evolution_dict_timer)
    4. Если detected > known → добавляем новые маркеры
       - timestamp = current_time + EVO_MARKER_DISPLAY_TIME
       - status = "detect"

Вспомогательные функции (используются в card_manager.py):
- find_oldest_detect_marker(evolution_dict_timer):
    Возвращает min(timestamp) со статусом "detect"

- mark_evolution_as_recorded(evolution_dict_timer, timestamp):
    Меняет статус на "record"

- check_evolution_dict_timeout(evolution_dict_timer, current_time):
    Удаление истекших маркеров

5.5 FUNCTIONS.PY - ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
------------------------------------------

def iou_box(box_a, box_b, alpha=1, sigma=0.9):
    Композитный скор схожести боксов:
    score = alpha * IoU + (1 - alpha) * exp(-(d/(sigma*D))^2)
    Возвращает [0, 1], где 1 - идентичные боксы.

def cnt_box_timer(timer_obj):
    Подсчитывает количество непустых box_timer в timer_obj.
    Возвращает 0-6.

def group_class_name(rows, threshold=3):
    Группирует class_name по встречаемости.
    Возвращает список class_name с подтверждением >= threshold.

def boxtimer_to_boxzone(box_timer):
    Расширяет box_timer в зону отслеживания:
    - x: ±2 ширины
    - y: +2 высоты вверх
    - Ограничение границами ROI

def group_box_lvl(timer_obj, threshold=3, iou_threshold=0.7):
    Группирует box_lvl по IoU схожести.
    Возвращает количество групп с размером >= threshold.

================================================================================
6. ДЕТАЛИ РЕАЛИЗАЦИИ
================================================================================

6.1 НЕЙМИНГ КЛАССОВ CV МОДЕЛИ
-----------------------------

CV модель детектирует 165 классов (при 121 карте в игре).
Одна карта может иметь несколько class_name в зависимости от места детекции.

Префиксы class_name:
- Первая буква (тип):
  * W - Warrior (юнит)
  * B - Building (здание)
  * S - Spell (заклинание на поле)
  * A - Ability (абилка чемпиона)
  * Z - Zone icon (заклинание в НАШЕЙ руке)
  * _ - технический объект

- Вторая буква (редкость):
  * C - Common (обычная)
  * R - Rare (редкая)
  * E - Epic (эпическая)
  * L - Legend (легендарная)
  * C - Champion (чемпион)

Примеры:
- "WC skeleton" - скелет (юнит, обычный)
- "SE rage" - рейдж (заклинание на поле, эпическое)
- "Z rage" - рейдж (в НАШЕЙ руке)
- "AC archer queen" - абилка королевы лучниц
- "_ timer red" - красный таймер (технический)
- "_ lvl red" - красный уровень (технический)
- "_ lvl red cham" - красный уровень чемпиона
- "_ evolution mark" - маркер эволюции
- "_ finish" - конец боя
- "_ start" - начало боя

6.2 ЛОГИКА ЦИКЛА КАРТ
---------------------

Колода противника: 8 карт (deck = await + hand)
- await_cards[4]: ожидающие карты (слева на панели)
- hand_cards[4]: карты в руке (справа на панели)

Начальное состояние:
- deck_cards = [121 карта] (все карты игры)
- await_cards = [?, ?, ?, ?] (4 заглушки)
- hand_cards = [?, ?, ?, ?] (4 заглушки)

Отыгрыш НОВОЙ карты (из deck):
1. Удаляем крайний левый "?" из hand
2. await[3] → hand[освободившийся индекс]
3. await сдвигается вправо
4. Новая карта → await[0]
5. Новая карта удаляем из deck_cards

Отыгрыш ИЗВЕСТНОЙ карты (из hand):
1. Удаляем карту из hand
2. await[3] → hand[освободившийся индекс]
3. await сдвигается вправо
4. Карта возвращается → await[0]

Пример последовательности:
Начало:                    [?, ?, ?, ?] [?, ?, ?, ?]
Сыграна новая "Giant":     [Giant, ?, ?, ?] [?, ?, ?, ?]
Сыграна новая "Arrows":    [Arrows, Giant, ?, ?] [?, ?, ?, ?]
Сыграна новая "Rage":      [Rage, Arrows, Giant, ?] [?, ?, ?, ?]
Сыграна новая "Skeleton":  [Skeleton, Rage, Arrows, Giant] [?, ?, ?, ?]
Сыграна новая "Vines":     [Vines, Skeleton, Rage, Arrows] [Giant, ?, ?, ?]
Сыграна известная "Giant": [Giant, Vines, Skeleton, Rage] [Arrows, ?, ?, ?]
Сыграна новая "Rascals":   [Rascals, Giant, Vines, Skeleton] [Arrows, Rage, ?, ?]
Сыграна известная "Rage":  [Rage, Rascals, Giant, Vines] [Arrows, Skeleton, ?, ?]
Сыграна новая "Hunter":    [Hunter, Rage, Rascals, Giant] [Arrows, Skeleton, Vines, ?]

6.3 РАСЧЕТ ЭЛИКСИРА
-------------------

Формула обновления:
elixir_balance = prev_balance + delta_time * elixir_speed * elixir_rate - elixir_spent

Параметры:
- elixir_speed = 0.35 (базовая скорость прироста эликсир/сек)
- elixir_rate = 1.0 / 2.0 / 3.0 (множитель x1/x2/x3)
- elixir_balance: [0, 10] (лимитируется)

Метрики (для валидации):
- elixir_negative: сумма эликсира ушедшего в минус
- elixir_stagnation: простаиваемый эликсир, сумма эликсира ушедшего выше 10

Логика:
1. Вычисляем прирост: add_elixir = delta_time * speed * rate
2. Обновляем баланс: balance = balance + add_elixir - spent
3. Если balance > 10 → stagnation += (balance - 10), balance = 10
4. Если balance < 0 → negative += abs(balance), balance = 0

6.4 ВИЗУАЛИЗАЦИЯ (OVERLAY)
--------------------------

StaticOverlay (один раз при запуске):
- Доска: ширина 80% ROI, высота 8.5% ROI
- Капелька эликсира: размер 5% ROI, отступ 1% ROI
- Позиция: верхний левый угол ROI
- Цвет: RGB(240, 76, 76), прозрачность 50%

DynamicOverlay (каждый кадр):
- Шкала эликсира: ширина 70% ROI, высота 60% капельки
- Цифра эликсира: поверх капельки, размер 50% капельки
- 8 карт (4 await + 4 hand):
  * Позиционирование: между шкалой и нижней границей доски
  * Масштаб: CARD_SCALE = 0.2
  * Поддержка эво-версий (если cnt_evo >= target_evo)

Технология:
- Tkinter для создания окон
- overrideredirect(True) - безрамочный режим
- attributes('-topmost', True) - поверх всех окон
- attributes('-transparentcolor', COLOR_BACKGROUND) - прозрачность
- WS_EX_TRANSPARENT | WS_EX_LAYERED - click-through (Windows API)

6.5 СКОЛЬЗЯЩИЕ ОКНА
-------------------

log_screen: deque(maxlen=4)
- Автоматическое удаление старых кадров
- Используется для list_ignore в timer_processor

timer_obj: список из 6 timer_screen
- cleanup_timers() удаляет последний элемент у всех timer_obj
- Новые timer_screen добавляются в начало (insert 0)
- Если 5 элементов → заполняем 6-й пустым

spell_dict_hand: {"ZE_rage": [1,0,0,0], ...}
- cleanup_spell_dict_hand() удаляет последний элемент каждого списка
- update_spell_dict_hand() добавляет 1 или 0 в начало
- [0,0,0,0] → перенос в spell_dict_our

Таймауты (spell_dict_our, spell_dict_enemy, ability_dict_enemy):
- check_spell_dict_timeout() / check_ability_dict_timeout()
- Фильтрация: [t for t in timeouts if current_time < t]
- Удаление пустых ключей

6.6 ОБРАБОТКА ОДНОВРЕМЕННЫХ ДЕТЕКЦИЙ
------------------------------------

Проблема: Зеркальные матчи (одинаковые колоды у игроков).
Может быть до 2 одинаковых заклинаний на поле одновременно.

Решение (spell_processor):
1. Подсчет детекций: detected_spells_count[class_name]
2. Подсчет известных: our_count + enemy_count = total_known
3. Если detected > known → new_enemy_count = detected - total_known
4. Списание эликсира ОДИН раз (даже если new_enemy_count > 1)
5. Добавление таймаутов для ВСЕХ new_enemy_count

Пример:
detected = 2 (два "SE_rage" на поле)
our = 1 (НАШЕ заклинание в spell_dict_our)
enemy = 0 (нет в spell_dict_enemy)
→ new_enemy = 2 - 1 = 1
→ списываем эликсир ОДИН раз
→ добавляем ОДИН таймаут в spell_dict_enemy

6.7 УСЛОВИЯ ПОДТВЕРЖДЕНИЯ ТАЙМЕРА
---------------------------------

Усл.1: Подсчет box_timer
- cnt_box_timer(timer_obj) >= 3
- Если 0 → удаляем timer_obj (не видно 1.5 сек)
- Если 1-2 → пропускаем (недостаточно подтверждений)

Усл.2: Подсчет box_lvl
- group_box_lvl(timer_obj) >= 1
- Группировка по IoU >= 0.7
- Минимум 3 бокса в группе

Усл.3: Подсчет class_name
- group_class_name(rows) не пустой
- Группировка по встречаемости >= 3
- Исключение: "_bomb" → удаляем timer_obj

Если усл.1,2,3 выполнены:
- Фильтрация: удаляем list_ignore из group_class_name
- Поиск карты: hand → deck → await
- Запуск цикла карт + списание эликсира

6.8 ОТЛАДКА И ЛОГИРОВАНИЕ
-------------------------

Уровни логирования (logging):
- WARNING: критические ошибки, метрики (продакшн)
- INFO: детальная информация (отладка)

Настройка в app.py:
logging.basicConfig(level=logging.WARNING, ...)

Режим отладки (config.py):
DETECTION_TEST = True/False
- Сохранение кадров с детекциями в detection/
- Формат: HH-MM-SS-ms.png

Вывод в терминал (app.py):
- Timestamp
- Количество детекций
- Баланс эликсира (balance, negative, stagnation)
- Цикл карт (await, hand)
- Время обработки (capture, detection, processing, overlay, save)

Метрики производительности:
- frame_time: захват кадра
- detection_time: YOLO инференс
- processing_time: обработка детекций (handler + процессоры)
- overlay_update_time: обновление оверлея
- save_time: сохранение кадра (если DETECTION_TEST)

================================================================================
КОНЕЦ ДОКУМЕНТАЦИИ
================================================================================

Версия: 2.0
Дата: 2025-10-25
Автор: Clash Royale Bot Team
