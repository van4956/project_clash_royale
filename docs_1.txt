=== docs_1.txt ===

(документ был создан после реализации overlay,
для описания струкуры и архетиктуры будущего проекта,
написан своими словами.
документ морально устарел!!!
в ходе разработки были внесени корректировки.
реальный проект во многих моментах не соответствует описанному в документе.
документ сохранен для истории)



=== ОБЪЕКТЫ ===

КЛАССЫ (объекты ООП, прописаны в classes.py)

Card(): название (реальное на анг), ссылка на картинку в проекте, стоимость карты (число элика),
список классов class_name которые детектит модель (обычно 1 к 1, но есть банда гоблинов где 3 гоблина и три копейщика),
Champion (true/false), абилка (class_name/none), стоимость абалики (число элика/0),
Evolution (true/false), cnt_evo=0, target_evo=0 (сколько эво маркеров надо для еволюции),
ссылка на картинку ево карты.

TimerObject(timer_obj): дополнительные атрибуты: first_screen, last_screen, list_ignore

ПЕРЕМЕННЫЕ

iou_proc = 0.7, пороговое значение, при значении iou более которого будем считать два бокса одинаковыми
len_win = 6, длинна окна (далее все 6 это len_win)
line_conf = 3, пороговое значения принятия (далее все 3 это line_conf)

log_screen = {time:[detection],time:[detection],time:[detection],time:[detection]} - словарь, с 4мя последними кадрами,
в виде ключ:значение, где ключ - время, значение - инфа которую нам передает cv модель.

timer_screen = [[box_timer],[box_zone],[[box_lvl],[box_lvl],],[class_name, class_name,]], массив данных
timer_obj = [], состоит из 6 timer_screen
timer_list = [], собирает все timer_obj, глобальная переменная, типа бд

ability_screen = [[box_ability],[box_lvl]]
ability_obj = [], состоит из 6 ability_screen
ability_list = [], список для отслеживания абилок, собирает в себя все ability_obj, глобальная переменная, типа бд

spell_dict_time = {}, словарь наших заклинаний, которые мы сыграли несколько мгновений назад.
spell_dict_list = {}, словарь учета наших заклинаний, в нашей руке

ФУНКЦИИ (прописаны в functions.py)

iou_box(), расчет схожести двух боксов, возвращает процент похожести (пока что строго по iou)

cnt_box_timer(), подсчет наличия всех box_timer (из timer_screen) в timer_obj

boxtimer_to_boxzone(), изменение координат, создание отслеживаемой зоны, типа x1-2*l,y1+2*h,x2+2*l,y2

group_box_lvl(), группировка box_lvl (из timer_screen) в timer_obj по пересечению их координать (x1,y1,x2,y2),
возвращаем цифру, количество групп у которых элементов было >=3

group_class_name(), группировка class_name (из timer_screen) в timer_obj,
в одном timer_screen может быть несколько одинаковых class_name (["WC_sceleton","WC_sceleton","SE_rage"]),
возвращаем спискок class_name у которых после группировки было >=3



=== ЗАПУСК ПРОГРАММЫ ===

при запуске программы создаем и запускаем процессы описанные в app.py (небольшая корректировка текущего состояния)
    Последовательность работы:
    1. Инициализация модулей (захват экрана, детектор)
    2. Выбор области экрана (ROI)
    3. Загрузка модели YOLO
    4. Цикл: захват кадров → детекция (ищим _vs)
    5. Создание массиво с картами
    6. Цикл: захват кадров → детекция (ищим _total_time)
    7. Инициализация подсчет эликсира, создание статичного overlay (доска, капелька)
    8. Основной цикл: захват кадров → детекция → вывод результата (терминал, динамический overlay)
    9. Детекция (ищим _finish) → очистка ресурсов при завершении

пункт.4 начинаем процесс детекции моделью по 4 кадра в секунду (интересует только _vs)
после детекции класса _vs, создаем список deck_cards = [] в который копируем все имеющиеся объекты карт (все 121 из total_card.py)
создаем переменные await_cards = [] и hand_cards = [], списки ожидающих карт, и тех что в руке, заполняем их по 4 card_random()

(данная программа реализуится на python под ОС Windows11, в тестовом режиме, для проверки и отладки алгоритма и CV модели,
в дальнейшем при переносе на Android процессы будут переработаны, переменные масивов будут создаваться перед каждым боем)
сейчас для отладки я буду сам запускать программу непосредственно перед каждым боем.

после первой детекции класса _total_time (п.6) делаем запись начала времени, для подсчета эликсира,
запускаем процессы подсчета элексира, запускаем процессы отрисовки панели, файлы статичного overlay
игра пошла, система отслеживает по 4 кадра в секунду, модель детектирует каждый кадр (п.8),
описывает полученные объекты названиями классов, координатами их рамок, и уверенность,
алгоритм обрабатывает каждую порцию полученной информации каждого кадра,
если обнаружена карта противника (персонаж, здание, закоинание, абилка чемпиона), в зависимости от условий,
запускается цикл смены карт противника, списывается часть элексира,
и так по кругу пока игра не закончится (п.9), или игрок не завершит процесс программы.



=== ЦИКЛ КАРТ ===

карта заглушка, для корректоного отображения цикла карт, когда еще не знаем все карты противника

колода карт - это все 121 возможные карты, без повторов,
    классы карт будут наследоваться от Card(),
    карты будут прописаны соответственно реальным картам и хранится в системе в файле total_card.py
    названия будут формироваться так: card_sceletons() это card_ + реальное название карты
    в папке data будут картинки всех карт в формате card_sceletons.png
    для эволюционных версий card_sceletons_evo.png
    всего получится 121 класс, столько же сколько карт в реальной игре
    перед началом боя будет создаваться массив deck_cards, в который будет копироваться все карты 121 карты из total_card.py

арсенал - это 8 карт противника, которые он выбрал себе в рамках боя,
    на старте это будет 8 card_random, далее по ходу игры card_random будут заменяться картами из колоды карт deck_cards,
    массив арсенала будет состять из await_cards = [] и hand_cards = []

рука - это 4 карты из 8 карт арсенала, которые доступны игроку прямо сейчас,
    будут находится в hand_cards, в начале боя заполнен 4мя card_random.
    игрок может сыграть карту из руки их если баланс элексира позволяет,
    но мы это ограничивать пока не будет, просто элексир будет спускать до минимально возможного, до 0.

ожидающие - это 4 карты которые ожидают своего перехода в руку, чтобы от туда уже попасть на поле боя,
    будут находится в await_cards, в начале боя заполнен 4мя card_random.
    если карта известна (не card_random) и находится в ожидании, ее разыграть нельзя.

на панеле (которую мы уже прописали в overlay) всегда визуализируем 8 карт: 4 левее, 4 правее
это будет арсенал карт противника которые он выбрал себе на бой
4 карты что правее это рука противника (hand_cards)
4 карты что левее это ожидающие, те что будут сменять карты из руки (await_cards)
дживение из ожидания в руку и обратно, это и есть цикл карт который мы пытаемся определить

в начале боя все 8 карт это card_random (картинка карты "?")
пример панели:
[? ? ? ?   ? ? ? ?]
[1 2 3 4   5 6 7 8] для условности буду называть их порядковыми номерами
[ await     hand  ]

по мере игры, детекции объектов на поле, и анализу, будем обнаружать какие карты сыграл противник,
согласно сыгранным картам списываем соответствующее количество элексира и запускаем анимацию цикла карт.



=== ЦИКЛ КАРТ ВИЗУАЛЬНО ===

определяем 8 точек для восьми карт (центры прямоугольников)
располагаем на каждую точку карты заглушки card_random() (их центры в точки)
карты все немного разные, так что картинки будут не много дергаться, но это приемлемо, тк как это бета версия.
главное проработать алгоритм расчета.

первая сыгранная карта противника, это первая карта (5) в правой четверке (hand_cards),
карта сдвигается на полкорпуса вниз и растворяется,
на место ушедшей карты сдвигается карта крайняя правая (4) из левой четверки (await_cards),
в левой четверке все оставшиеся карты (1,2,3) сдвигаются на одну позицию направо,
занимая позиции 2,3,4 соответственно, первая позиция в левой четверки станет пустой,
на полкорпуса ниже этой пустой позиции, начнет появлятся обнаруженная нами карта (alpha 0.5->1),
пока полностью не встанет на позицию крайняя левая (1) в левой четверке (await_cards),
цикл замкнулся.

далее, по мере разыгрывания карт,
если сыграна известная карта из руки (hand_cards),
то она опускаеся вниз, растворяется, и потом появется на первой позиции левой четверке (await_cards),
в левой четверке все карты двигаются только слева на право,
все (1,2,3) карты сдвигаются на одну позицию вправо, кроме 4ой карты,
4ая перемещается на пустую позицию правой четверки (может быть любой индекс), на то место от куда вышла карта,
двигаться она будет быстрее первых трех, тк за то же время ей нужно будет пролететь большее растояние.

если обнаружена новая (еще неизвестная) карта, то вниз смещается крайняя левая карта рандом из оставшихся card_random в руке (hand_cards),
далее прокручивается стандартный цикл (описанный ранее),
получается что самая последняя неизвестная карта card_random() будет стоят в крайней правой позиции (8),
[с с с с   с с с ?]
пока противник ее не разыграет, мы ее определить не сможем, и в руке будет стоят карта со знаком вопроса.
так может быть хоть до самого конца боя. механика игры позволяет обходится минимум 5ю картами чтобы цикл крутился.
три оставшиеся карты могут находится закрытими сколь угодно долго. это зависит от тактики противника.



=== ЦИКЛ КАРТ В КОДЕ ===

имеем три списка:
deck_cards = {}, множество, все карты, вначале там 121 карта
await_cards = [], очередь, заполнен 4мя card_random,
hand_cards = [], список, заполнен 4мя card_random.

когда игрок сходил какую то карту, и мы определиле что это за карта,
если это новая карта,
    удаляем крайнюю левую card_random, из hand_cards,
    на освободившеееся место ставим крайнюю правую карту из await_cards,
    смещаем оставшися карты в await_cards в право,
    на первую позицию в await_cards ставим новую определенную нами карту из deck_cards,
    в deck_cards должно стать на 1 карту меньше.
если это имеющуюся карта в руке,
    определяем ее позицию и удаляем из hand_cards,
    на освободившеееся место ставим крайнюю правую карту из await_cards,
    смещаем оставшися карты в await_cards в право,
    на первую позицию в await_cards ставим карту которую удалили из hand_cards.

await_cards это по сути очередь.
hand_cards это типа список, у которого мы делаем замену по индексу.
а deck_cards это общий хаб, от куда берем карты, пока не заменим все card_random в await_cards и hand_cards.

в сумме во всех трех списках всегда должно получаться 121 уникальная карта + [0-8] card_random.
создать список с координатами точек в центры которых помещать картинки соответствующих карт.
проверять если target_evo = cnt_evo, в картах hand_cards, то отрисовывать ево версию карты, а также обнуляем cnt_evo.
cor_await_cards = [(x0,y0),(x1,y1),(x2,y2),(x3,y3)], типа список координать соответствующих карт списка await_cards.
расчитывается от размера доски, позиции шкалы.
для cor_hand_cards аналогично.


=== КРАСНЫЙ ТАЙМЕР ===

самое важное в общем цикле детекции - красный таймер (_timer red), это сигнал что противник сыграл карту типа: юнит, здание.

вначале, после каждой детекции, мы пробегаемся по timer_list, во всех timer_obj удаляем последний элемент.

если модель детектирует таймер (возможен один или несколько таймеров в моменте, в кадре)
создаем timer_screen:
    структура timer_screen такая [[box_timer],[box_zone],[[box_lvl],[box_lvl],],[class_name, class_name,]]
    берем координаты бокса таймера полученные от модели детекции
    помещаем на первую позицию timer_screen (box_timer - это x1,y1,x2,y2).
    рассчитываем зону для поиска уровней и персонажей, в виде обновленных координат (box_zone),
    помещаем в timer_screen список box_zone,
    по box_zone находим все красные уровни, записываем их боксы в список, добавляем в timer_screen,
    по box_zone находим все элементы, записываем название их классов, добавляем в timer_screen,
    по box_zone находим все элементы в log_screen записываем список class_name без повторов в переменную list_ignore,
    так отслеживаем объекты которые были в зоне за секунду до таймера.

проходимся итеративно по timer_list, в каждом timer_obj смотрим на первый столбец,
это первый элемент каждого timer_screen в timer_obj,
идем сверху вниз (от настоящего в прошлое), ищим первое не пустое значение,
проверяем на перерсечение box_timer из timer_obj и box_timer из созданного timer_screen (созданных timer_screen возможно >1):
если соответствия нет, или timer_list вообще пуст, создаем новый timer_obj:
    созданый ранее timer_screen помещаем на первую позицию
    следом создаем 5 пустых timer_screen
    заполняем значения first_screen, last_screen
    переносим список list_ignore в атрибут timer_obj.list_ignore
    получаем timer_obj, состоящий из 6 timer_screen, каждый из которых состоит из 4 списков
    помещаем его в timer_list
если соответствие есть
    вставляем timer_screen на первую позицию timer_obj
    обновляем last_screen

проходимся итеративно по timer_list,
проверяем количество элементов в каждом timer_obj,
если 5 (меньше не должно быть):
    создаем пустой timer_screen,
    на позицию box_zone копируем box_zone из первого элемента timer_obj
    находим все красные уровни, записываем их box_lvl в список, и добавляем в timer_screen.
    по box_zone находим все элементы, записываем их class_name, и добавляем в timer_screen.
    обновляем last_screen
    проверяем что в timer_obj 6 элементов
    запускаем "процесс проверки условий"
если 6:
    запускаем "процесс проверки условий"

"процесс проверки условий"
применяется итеративно в timer_list к каждому timer_obj:
    усл.1 - подсчет наличия всех box_timer (из timer_screen) в timer_obj
    применяем функцию cnt_box_timer()
    значения могут получиться от 0 до 6:
    если 0:
        это значит что таймер не был виден 1.5 сек
        удаляем весь объект timer_obj из timer_list, и переходим к следующему timer_obj
    если 1, 2:
        переходим к следующему timer_obj
    если 3, 4, 5, 6:
        усл.2. - подсчет и группировка box_lvl из всех timer_screen
        применяем функцию group_box_lvl()
        возращаем цифру, количество боксов, у которых после группировке получилось >=3
        усл.3. - подсчет и группировка названий классов из всех timer_screen
        применяем функцию group_class_name()
        возвращаем список group_class_name кассов, у которых после группировки получилось >=3
    если усл.3 определило class_name = _ bomb, удаляем timer_obj
        у всех бомб всегда есть таймер
        все бомбы это всегда эффекты после смерти кого-то (бомба шарига, гигскелета, башни бомбежки)
    если, и усл.2., и усл.3., вернули какие то ответы:
        проверяем "условия игнорирования": (пока эти 2 строки пропускаем)
            если что-то совпало - удаляем timer_obj, и переходим к следующему timer_obj
        # удаляем из получившегося списка group_class_name все class_name карт из await_cards,
        удаляем из получившегося списка group_class_name все class_name карт из timer_obj.list_ignore
        (это довольно жесткое условие, пока только для теста, далее смягчим условия, сделаем более гибкими,
        добавим еще проверки по таймеру, "первый пришел, первый ушел", чтобы избежать ситуаций -
        таймер с картой пришли раньше, но из за шумов дольше получали подтверждение,
        в итоге таймер с картой идущие на 0.250мс следом, будут разыграны раньше, это полностью "сломает" цикл)
        определяем класс сыгранной карты:
            проверяем список group_class_name() со всеми class_name из hand_cards,
            если совпадений не нашлось, и в hand_cards есть card_random,
            тогда ищем соответствие class_name из deck_cards,
            если не нашлось, ни где, ищим в await_cards (это будет значит что у нас сместился цикл)
            если ни чего совсем нигде не нашлось, переходим к следующей итерации timer_obj,
            (оставляем как есть, в дальнейшем надо будет разобрать такой кейс, пока что оставим так,
            timer_obj самоуничтожится через 6 кадров, когда перестанет детектить таймер)
            если соответствие находим:
                запускаем цикл смены карт в коде
                запускаем анимацию смены карт (прописать в overlay_dinamic.py)
                расчет изменения эликсира (прописать в app.py)
                анимация изменения эликсира (прописать в overlay_dinamic.py)
                удаляем timer_obj
                переходим к следующей итерации, timer_obj
    иначе если:
        переходим к следующему timer_obj

"условия игнорирования" - условия при которых все усл. сработали (1,2,3), но эликсир списывать НЕ надо, и цикл НЕ меняем
(пока пропускаем, в нашем наборе карт (13) таких ситуаций нет)



=== ЗАКЛИНАНИЯ ===

отыгрыш заклинаний не маркируется таймерами, ни красными, ни синими.
при отыгрыше заклинания красный таймер (_timer red) мы НЕ отловим.
определение заклинания будет происходить по детекции эффекта заклинания на поле,
и сопоставлению имееющегося заклинания в нашей руки.

вначале, когда мы пробегаемся по timer_list, мы также проверяем и spell_dict_list и spell_dict_time,
spell_dict_list это словарь структуры {"class_name":[1,0,0,0],"class_name":[1,1,1,1],}
spell_dict_time это словарь структуры {"class_name":time, "class_name":time,}

при детекции карты заклинания в нашей руке (которую мы видим, это НЕ рука противника),
ищем ее в ключах словаря spell_dict_list,
если находим, делаем вставку единицы в списке соответствующего class_name,
если не неходим, создаем новую пару ключ:значение вида "class_name":[1,0,0,0],
в spell_dict_list мы фиксируем присутствие заклинания у меня, как только оно уйдет, это ситуация "class_name":[0,0,0,0],
это будет через 4 кадра, или через 1 секунду как оно исчезнет из моей руки,
тогда мы зафиксируем это заклинание в spell_dict_time.

в spell_dict_time записываем пару ключ:значение class_name:time заклинания,
в time записываем текущее время + определенное количество сек, то сколько оно отыгрывается,
через ~1 секунду моё заклинание будет отыгранно на поле боя (начнет визуализироваться),
spell_dict_time это список наших заклинаний, с контролем временим,
если в этот промежуток времени будет задетекчено заклинание на поле боя, алгоритм поймет что это наше заклинание, и не будет
запускать цикл карт у противника, и не будет у него списывать элек за заклинание.
если будет задетекчено два похожих заклинания, то будет запущен цикл.
опасаться за двойное списание не стоит, тк как только карта запускает цикл карт, она сразу попадает в await_cards,
а от туда карты не могут запустить цикл.

когда детектируем заклинание на поле, сверяемся со spell_list,
если видим там такое же заклинание, НЕ вычеркиваем его (самоочистка в другом месте),
если не находим, значит это было заклинание противника,
тогда запускаем цикл карт противника и расчет эликсира противника.

вначале когда подчищаем хвосты всем основным спискам, в spell_dict_time сверяемся со временем,
если таймер вышел, удаляем запись.



=== АБИЛКИ ЧЕМПИОНОВ ===

абилки чемпионов не влияют на ратацию карт в руке
просто отслеживаем все детектируемые class_name
сверяемся со всеми абилоками чемпионов (всего 8)
в вслучае детекции абилки создаем ability_screen = [[box_ability],[box_lvl]]
box_lvl это бокс красного уровня в определенном радиусе от обилки

проходимся итеративно по ability_list
если в нем присутствуют ability_obj, удаляем последний элемент у каждого

проходимся итеративно по ability_list
в каждом ability_obj, ищем сопоставление по box_ability (ability_screen)
если нашли сопоставление,
    добавляем в начало ability_screen
    проверяем количество элементов в ability_obj (должно быть 6)
если не нашли
    добавляем к ability_screen 5 пустых массивов в конец (должно получиться 6)
    добавляем новый ability_obj в ability_list

проходимся итеративно по ability_list
проверяем и абилку, и красный уровень (в ближайшем радиусе)
при соблюдении условий >=3 подтверждений из 6 последних
и если, подходящая карта в арсенале противника присутствует
    удаляем созданный объект из ability_list
    списываем определенное количество элексира
    запускаем анимацию элексира
    выходим из цикла
если подходящей карты в арсенале противника нет,
    удаляем созданный объект из ability_list
    фиксируем ошибку в лог
    пытаемся перейти к следующей итерации (если вдруг в ability_list было >1 ability_obj)



=== МАРКЕР ЭВОЛЮЦИЙ ===

маркер эволюции сигнализирует что была сыграна карта эволюции.
маркер подсвечивает только вражеские эволюции (это удобно).
смотрим на текущую отыгранную карту противника,
там у карты должна быть evolution=True, меняем cnt_evo+=1, всё.
при выводе отрисовке карты в руке смотрим,
если cnt_evo = target_evo, отрисовывем эво версию, cnt_evo обнуляем.
если здесь случится ошибка, вообще ни чего страшного, просто будет отрисована другая картинка.


===========================

Версия: 1.6
Дата: 2025-10-15
Автор: Van